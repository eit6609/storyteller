'use strict';

const
    { forEach, toPairs } = require('lodash'),
    Generator = require('../../src/generator.js'),
    Page = require('../../src/page.js'),
    Template = require('../../src/template.js');

describe('Generator', () => {
    let factory, options, sut;
    beforeEach(() => {
        factory = {
            createPage () {
            },
            createTemplate () {
            },
            createEPUBCreator () {
            }
        },
        options = {
            templatesDir: 'templates-dir',
            outputDir: 'output-dir',
            metadata: {
                filename: 'a-filename',
                author: 'an-author',
                title: 'a-title',
                language: 'a-language',
                cover: 'a-cover'
            },
            markdown: false,
            debug: true,
            factory
        };
    });
    describe('constructor()', () => {
        it('should throw if the options are not valid', () => {
            try {
                sut = new Generator({});
                fail();
            } catch (error) {
                expect(error.message).toBe('Invalid options {}: "templatesDir" is required');
            }
        });
        it('should store the options', () => {
            sut = new Generator(options);
            expect(sut.templatesDir).toBe(options.templatesDir);
            expect(sut.outputDir).toBe(options.outputDir);
            expect(sut.metadata).toBe(options.metadata);
            expect(sut.markdown).toBe(options.markdown === true);
            expect(sut.debug).toBe(options.debug === true);
            expect(sut.createPage).toBe(options.factory.createPage);
            expect(sut.createTemplate).toBe(options.factory.createTemplate);
            expect(sut.createEPUBCreator).toBe(options.factory.createEPUBCreator);
        });
    });
    describe('generate()', () => {
        class MockPage extends Page {
            constructor (...params) {
                super(...params);
            }
            build () {
                this.text = `text of ${this.id} generated by ${this.template.name}`;
                switch (this.id) {
                    case 0:
                        this.goto('template-2', (state) => { state.a = 1; });
                        break;
                    case 1:
                        this.goto('template-1');
                        break;
                    case 2:
                        this.goto((state) => { state.a = 2; });
                        break;
                }
            }
            savePage () {
            }
        }
        class MockTemplate extends Template {
            constructor (...params) {
                super(...params);
            }
            load () {
            }
        }
        it('should generate the expected pages, call savePage() on each of them and then call sut.printReport() ' +
            'and sut.createEpub()', async () => {
            const initialTemplateName = 'template-1';
            const initialState = {};
            const expectedPages = [{
                key: 'template-1/{}',
                id: 0,
                state: {},
                text: 'text of 0 generated by template-1'
            }, {
                key: 'template-2/{a=1}',
                id: 1,
                state: { a: 1 },
                text: 'text of 1 generated by template-2'
            }, {
                key: 'template-1/{a=1}',
                id: 2,
                state: { a: 1 },
                text: 'text of 2 generated by template-1'
            }, {
                key: 'template-1/{a=2}',
                id: 3,
                state: { a: 2 },
                text: 'text of 3 generated by template-1'
            }];
            spyOn(factory, 'createPage').and.callFake((...params) => {
                const page = new MockPage(...params);
                spyOn(page, 'savePage');
                return page;
            });
            spyOn(factory, 'createTemplate').and.callFake((...params) => new MockTemplate(...params));
            sut = new Generator(options);
            spyOn(sut, 'createEpub').and.returnValue(Promise.resolve());
            spyOn(sut, 'printReport').and.callThrough();
            await sut.generate(initialTemplateName, initialState);
            forEach(toPairs(sut.pages), ([key, page], index) => {
                expect({
                    key,
                    id: page.id,
                    state: page.state,
                    text: page.text
                }).toEqual(expectedPages[index]);
                expect(page.savePage).toHaveBeenCalled();
            });
            expect(sut.createEpub).toHaveBeenCalled();
            expect(sut.printReport).toHaveBeenCalled();
        });
    });
    describe('getPage()', () => {
        it('should return the page if it exists', () => {
            sut = new Generator(options);
            sut.pages = new Map([['a-template/a-state', 'page']]);
            expect(sut.getPage('a-template', 'a-state')).toBe('page');
        });
        it('should call sut.getTemplate() and create the page if it does not exist, then set it in sut.pages and ' +
            'add it to sut.queue and increment sut.numberOfPages', () => {
            spyOn(factory, 'createPage').and.returnValue('a-page');
            sut = new Generator(options);
            sut.pages = new Map();
            sut.queue = [0];
            sut.numberOfPages = 20;
            spyOn(sut, 'getTemplate').and.returnValue('a-template');
            expect(sut.getPage('a-template', 'a-state')).toBe('a-page');
            expect(sut.numberOfPages).toBe(21);
            expect(sut.queue).toEqual([0, 'a-page']);
            expect(sut.pages.get('a-template/a-state')).toBe('a-page');
            expect(factory.createPage).toHaveBeenCalledWith(20, 'a-template', 'a-state', sut);
        });
    });
    describe('getTemplate()', () => {
        it('should return the template if it exists', () => {
            sut = new Generator(options);
            sut.templates = new Map([['a-template', 'template']]);
            expect(sut.getTemplate('a-template')).toBe('template');
        });
        it('should create the template if it does not exist and then set it in sut.templates', () => {
            spyOn(factory, 'createTemplate').and.returnValue('a-dummy-template');
            sut = new Generator(options);
            sut.templates = new Map();
            expect(sut.getTemplate('a-template')).toBe('a-dummy-template');
            expect(sut.templates.get('a-template')).toBe('a-dummy-template');
            expect(factory.createTemplate).toHaveBeenCalledWith('a-template', sut);
        });
    });
    describe('createEpub()', () => {
        it('should call epubCreator.create() with the right parameters', async () => {
            const epubCreator = {
                async create () {
                }
            };
            spyOn(factory, 'createEPUBCreator').and.returnValue(epubCreator);
            sut = new Generator(options);
            sut.numberOfPages = 4;
            spyOn(epubCreator, 'create');
            await sut.createEpub();
            expect(factory.createEPUBCreator).toHaveBeenCalledWith({
                contentDir: 'output-dir',
                spine: ['0000.html', '0001.html', '0002.html', '0003.html'],
                toc: [[{ label: 'Start', href: '0000.html' }]],
                cover: 'a-cover',
                simpleMetadata: {
                    author: 'an-author',
                    title: 'a-title',
                    language: 'a-language'
                }
            });
            expect(epubCreator.create).toHaveBeenCalledWith('a-filename');
        });
    });
});
